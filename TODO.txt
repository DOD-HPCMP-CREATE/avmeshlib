/** @page todo

Remove cell neighbor connectivity info (boundary faces will track their adjacent boundary patch ID, but internal cells will no longer track their adjacent cell IDs)

Change referenceLength from a scalar to a 3 float vector

Update the following unstruc metadata fields from 32-bit to 64-bit integers: nNodes, nFaces, nCells, n[Hex|Tet|Pri|Pyr]Cells, n[Bnd]TriFaces, n[Bnd]QuadFaces, n[Bnd]PolyFaces, nEdges, n[Nodes|Edges|Faces]OnGeometry

Higher order mesh support
* Remove polyFaces
* Add polynomialOrder (name?) metadata, defaults to 1
* If polynomialOrder > 1, use formulae to determine nNodes for each face/cell type
* Surface/volume can be at different order (tri/quad only higher order is possible)
* surfacePolyOrder, volumePolyOrder

Modify/extend geometry definition for AMR (this could entail the removal of the existing AMR heavy data fields)
(Looks like the existing AMR fields are OK, at least for Capstone. We could also potentially support Pointwise’s nmb format by interrogating the meshGenerator field)

Do we need to actually store mesh data on the surface in avm? This would fix some “edge” cases in AMR where you cannot determine which topology edge a mesh edge is on strictly by examining the topology edge that each mesh node is on

Todd suggested a “refined” metadata item that is only set on meshes that kestrel has refined. These meshes would not be user-visible/created. If flag is set we could read the rest of the mesh differently, using a new API with extra data somewhere to store refinement levels.

Jettison rev0 from repo, kestrel will use a handwritten reader to upconvert

Send Eric a detailed description of the AMR data to check that we really do have everything we need to talk to CapstoneSDK.

Steve Lamberson has a race condition (?) in the build system. See email for details (also tons of gcc warnings)

Todd's weird python-optimize bug

update rev2/test/read_avm_rev1.cpp and write_avm_rev1.cpp
*/
